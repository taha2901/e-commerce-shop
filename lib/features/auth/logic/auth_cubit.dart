
import 'package:ecommerce_app/core/helper/constants.dart';
import 'package:ecommerce_app/core/services/auth_services.dart';
import 'package:ecommerce_app/core/services/firestore_services.dart';
import 'package:ecommerce_app/features/auth/data/user_data.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
part 'auth_state.dart';

class AuthCubit extends Cubit<AuthState> {
  AuthCubit() : super(AuthInitial());
  final AuthServices authServices = AuthServicesImpl();
  final firestoreServices = FirestoreServices.instance;

  Future<void> loginWithEmailAndPassword(String email, String password) async {
    emit(AuthLoading());
    try {
      final user =
          await authServices.loginWithEmailAndPassword(email, password);

      if (user != null) {
        final userData = await firestoreServices.getDocument<UserData>(
          path: ApiPaths.users(user.uid),
          builder: (data, id) => UserData.fromMap(data, id),
        );
        emit(AuthSuccess(userData: userData));
      } else {
        emit(AuthError(message: "ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„"));
      }
    } on FirebaseAuthException catch (e) {
      String errorMsg = _handleFirebaseAuthError(e);
      emit(AuthError(message: errorMsg));
    } catch (e) {
      emit(AuthError(message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: ${e.toString()}"));
    }
  }

// Ø¯Ø§Ù„Ø© Ù…Ø¨Ø³Ø·Ø© ÙˆÙØ¹Ø§Ù„Ø©
  String _handleFirebaseAuthError(FirebaseAuthException e) {
    switch (e.code) {
      case 'invalid-email':
        return "ØµÙŠØºØ© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.";

      case 'user-disabled':
        return "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ ØªÙ… ØªØ¹Ø·ÙŠÙ„Ù‡.";

      case 'user-not-found':
        return "Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©";

      case 'wrong-password':
        return "Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©";

      case 'invalid-credential':
        return "Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©";

      case 'too-many-requests':
        return "Ø¹Ø¯Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙƒØ«ÙŠØ±Ø©ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹";

      case 'network-request-failed':
        return "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª";

      default:
        return "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©: ${e.message ?? e.code}";
    }
  }

  Future<void> registerWithEmailAndPassword(
      String email, String password, String username) async {
    emit(AuthLoading());
    try {
      final user =
          await authServices.registerWithEmailAndPassword(email, password);

      if (user != null) {
        final userData = UserData(
          id: user.uid,
          username: username,
          email: email,
          role: 'user',
          createdAt: DateTime.now().toIso8601String(),
        );

        await firestoreServices.setData(
          path: ApiPaths.users(user.uid),
          data: userData.toMap(),
        );

        emit(AuthSuccess(userData: userData));
      } else {
        emit(AuthError(message: "ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"));
      }
    } on FirebaseAuthException catch (e) {
      String errorMsg = _handleFirebaseAuthRegisterError(e);
      emit(AuthError(message: errorMsg));
    } catch (e) {
      emit(AuthError(message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: ${e.toString()}"));
    }
  }

// Ø¯Ø§Ù„Ø© Ù…Ø®ØµØµØ© Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
  String _handleFirebaseAuthRegisterError(FirebaseAuthException e) {
    switch (e.code) {
      case 'invalid-email':
        return "ØµÙŠØºØ© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.";

      case 'email-already-in-use':
        return "Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„.";

      case 'weak-password':
        return "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¶Ø¹ÙŠÙØ© Ø¬Ø¯Ø§Ù‹. ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„";

      case 'operation-not-allowed':
        return "Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± Ù…ÙØ¹Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹";

      case 'too-many-requests':
        return "Ø¹Ø¯Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙƒØ«ÙŠØ±Ø©ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹";

      case 'network-request-failed':
        return "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ©ØŒ ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª";

      default:
        return "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨: ${e.message ?? e.code}";
    }
  }

  Future<void> saveUserData(
      String userId, String email, String username) async {
    final userData = UserData(
      id: userId,
      username: username,
      email: email,
      role: 'user', // ğŸ‘ˆ Ù‡Ù†Ø§ Ù†Ø­Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±
      createdAt: DateTime.now().toIso8601String(),
    );
  }
    void checkAuth() async {
      emit(AuthChecking()); // Ø­Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø£ÙˆÙ„ÙŠ
      final user = authServices.currentUser();
      if (user != null) {
        try {
          final userData = await firestoreServices.getDocument<UserData>(
            path: ApiPaths.users(user.uid),
            builder: (data, id) => UserData.fromMap(data, id),
          );
          emit(AuthSuccess(userData: userData));
        } catch (e) {
          emit(AuthError(message: "Error fetching user data: $e"));
        }
      } else {
        emit(AuthInitial()); // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„
      }
    }

    Future<void> logOut() async {
      emit(AuthLogingout());
      try {
        await authServices.logOut();
        emit(AuthLogedout());
      } catch (e) {
        emit(AuthLogoutError(message: "Error: $e"));
      }
    }
}
